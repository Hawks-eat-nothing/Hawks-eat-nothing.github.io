<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一篇搞懂java泛型</title>
    <link href="/2022/05/13/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82java%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/05/13/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82java%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Java中的泛型是什么？使用泛型的好处是？"><a href="#Java中的泛型是什么？使用泛型的好处是？" class="headerlink" title="Java中的泛型是什么？使用泛型的好处是？"></a>Java中的泛型是什么？使用泛型的好处是？</h3><p>在集合中存储对象并在使用前进行类型转换很不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p><h3 id="泛型的种类有哪些？"><a href="#泛型的种类有哪些？" class="headerlink" title="泛型的种类有哪些？"></a>泛型的种类有哪些？</h3><ol><li>泛型类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> T key;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>实例化泛型类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><p>泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现泛型接口，不指定类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现泛型接口，指定类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">( E[] inputArray )</span><br>&#123;<br>    <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;<br>        System.out.printf( <span class="hljs-string">&quot;%s &quot;</span>, element );<br>    &#125;<br>    System.out.println();<br> &#125;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建不同类型数组：Integer, Double 和 Character</span><br>Integer[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>String[] stringArray = &#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br>printArray(intArray);<span class="hljs-comment">//1 2 3</span><br>printArray(stringArray);<span class="hljs-comment">//hello world</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="Java泛型是如何工作的？什么是类型擦除？"><a href="#Java泛型是如何工作的？什么是类型擦除？" class="headerlink" title="Java泛型是如何工作的？什么是类型擦除？"></a>Java泛型是如何工作的？什么是类型擦除？</h3><ul><li>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</li><li>编译器会在编译期间动态地将泛型T擦除为Object 或将T extends xxx擦除为限定类型xxx.</li><li>泛型本质上是编译器行为，为了保证引入泛型机制但不创建新的类型，减少虚拟机的运行开销，所以通过擦除将泛型类转化为一般类。</li></ul><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//不报错</span><br>list.add(<span class="hljs-number">12</span>);<br><br><span class="hljs-comment">//1.编译期间直接添加会报错</span><br>list.add(<span class="hljs-string">&quot;a&quot;</span>);<br><br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">List</span>&gt; clazz = list.getClass();<br><span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br><span class="hljs-comment">//2.运行期间通过反射添加，是可以的</span><br>add.invoke(list, <span class="hljs-string">&quot;kl&quot;</span>);<br><br>System.out.println(list)<span class="hljs-comment">//结果：[12, kl]</span><br></code></pre></td></tr></table></figure><h3 id="4-既然编译器要把泛型擦除，那为什么还要用泛型呢？用Object代替不行吗？-该题变相考察泛型的作用。"><a href="#4-既然编译器要把泛型擦除，那为什么还要用泛型呢？用Object代替不行吗？-该题变相考察泛型的作用。" class="headerlink" title="4. 既然编译器要把泛型擦除，那为什么还要用泛型呢？用Object代替不行吗？ 该题变相考察泛型的作用。"></a>4. 既然编译器要把泛型擦除，那为什么还要用泛型呢？用Object代替不行吗？ 该题变相考察泛型的作用。</h3><ul><li>可在编译期进行类型检测</li><li>使用Object类型需要手动添加强制类型转换，降低代码可读性，提高出错率。</li><li>泛型可以使用自限定类型。如 <code>T extends Comparable</code> 还能调用 <code>compareTo(T o)</code> 方法 ，Object<br>则没有此功能</li></ul><h3 id="5-什么是桥方法？"><a href="#5-什么是桥方法？" class="headerlink" title="5. 什么是桥方法？"></a>5. 什么是桥方法？</h3><p>桥方法用于继承泛型时保证多态。注意桥方法为编译器自动生成，非手写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T data;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T data)</span> &#123;<br>    <span class="hljs-built_in">this</span>.data = data; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(T data)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Node.setData&quot;</span>);<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;Integer&gt; &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyNode</span><span class="hljs-params">(Integer data)</span> &#123;<br>    <span class="hljs-built_in">super</span>(data); &#125;<br>    <span class="hljs-comment">//Node&lt;T&gt; 泛型擦除后为 setData(Object data)，而子类 MyNode 中并没有重写该方法，所以编译器会加入该桥方法保证多态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Object data)</span> &#123;<br>        setData((Integer) data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Integer data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyNode.setData&quot;</span>);<br>        <span class="hljs-built_in">super</span>.setData(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-泛型有哪些限制？为什么？"><a href="#6-泛型有哪些限制？为什么？" class="headerlink" title="6. 泛型有哪些限制？为什么？"></a>6. 泛型有哪些限制？为什么？</h3><p>泛型的限制一般是由泛型擦除机制导致的。擦除为 Object 后无法进行类型判断</p><ul><li>只能声明不能实例化 T 类型变量</li><li>泛型参数不能是基本类型。因为基本类型不是 Object 子类，应该用基本类型对应的引用类型代替</li><li>不能实例化泛型参数的数组。擦除后为 Object 后无法进行类型判断</li><li>不能实例化泛型数组</li><li>泛型无法使用 Instance of 和 getClass() 进行类型判断</li><li>不能抛出和捕获 T 类型的异常。可以声明</li><li>不能实现两个不同泛型参数的同一接口，擦除后多个父类的桥方法将冲突</li><li>不能使用static修饰泛型变量</li></ul><h3 id="7-以下代码是否能编译，为什么？"><a href="#7-以下代码是否能编译，为什么？" class="headerlink" title="7. 以下代码是否能编译，为什么？"></a>7. 以下代码是否能编译，为什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Algorithm</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">max</span><span class="hljs-params">(T x, T y)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &gt; y ? x : y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不能，因为 x 和 y 都会被擦除为 Object 类型， Object 无法使用 &gt; 进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>&lt;T&gt;();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">T</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>无法编译，不能使用 static 修饰泛型 T</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="通配符的作用"><a href="#通配符的作用" class="headerlink" title="通配符的作用"></a>通配符的作用</h3><p><strong>通配符是用来解决泛型无法协变的问题</strong>，一般用于声明方法形参，类之间继承关系并不适用于泛型，以下是泛型类之间的继承体系图</p><div align="center"><img src="泛型类型继承" width=500 ></div><h3 id="通配符-？-和常用的泛型-T-之间有什么区别？"><a href="#通配符-？-和常用的泛型-T-之间有什么区别？" class="headerlink" title="通配符 ？ 和常用的泛型 T 之间有什么区别？"></a>通配符 ？ 和常用的泛型 T 之间有什么区别？</h3><ul><li>T 可以用于声明变量或常量而 ? 不行</li><li>T 一般用于声明泛型类或方法，通配符 ? 一般用于泛型方法的调用代码和形参</li><li>T 在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型</li></ul><h3 id="无界通配符-？-的作用？"><a href="#无界通配符-？-的作用？" class="headerlink" title="无界通配符 ？ 的作用？"></a>无界通配符 ？ 的作用？</h3><ul><li>接受任何泛型类型数据</li><li>实现不依赖于具体类型参数的简单方法,如非空判断，size()，clear() 等方法</li><li>用于捕获参数类型并交由泛型方法进行处理</li></ul><h3 id="上界通配符-extends-xxx-和下界通配符-super-xxx-有什么区别？使用场景？"><a href="#上界通配符-extends-xxx-和下界通配符-super-xxx-有什么区别？使用场景？" class="headerlink" title="上界通配符 ? extends xxx 和下界通配符 ? super xxx 有什么区别？使用场景？"></a>上界通配符 <code>? extends xxx</code> 和下界通配符 <code>? super xxx</code> 有什么区别？使用场景？</h3><ul><li>使用 <code>? extends xxx</code> 声明的泛型参数只能调用 <code>get()</code> 方法返回 <code>xxx</code> 类型，调用 <code>set()</code> 报错。使用<code>? extends xxx</code> 声明的泛型参数只能调用 <code>set()</code> 方法接收 <code>xxx</code>类型，调用 <code>get()</code> 报错。</li><li>它们所接收参数的范围不同，详细见上图</li><li>根据 PECS 原则，即 producer-extends consumer-super 如果参数化类型表示一个生产者，就用?<br>extends xxx 声明，如果表示一个消费者，就用 ? super xxx 声明</li></ul><h3 id="T-extends-xxx-和-extends-xxx-又有什么区别？"><a href="#T-extends-xxx-和-extends-xxx-又有什么区别？" class="headerlink" title="T extends xxx 和 ? extends xxx 又有什么区别？"></a>T extends xxx 和 ? extends xxx 又有什么区别？</h3><p>T extends xxx 用于定义泛型类和方法，擦除后为 xxx 类型， ? extends xxx 用于声明方法形参，接收 xxx 和其子类型</p><h3 id="Class-和-Class-lt-gt-的区别？"><a href="#Class-和-Class-lt-gt-的区别？" class="headerlink" title="Class 和 Class&lt;?&gt; 的区别？"></a>Class 和 Class&lt;?&gt; 的区别？</h3><p>直接使用 Class 的话会有一个类型警告，使用 Class&lt;?&gt; 则没有，因为 Class 是一个泛型类，接收原生类型会产生警告</p><h3 id="以下代码是否能编译？"><a href="#以下代码是否能编译？" class="headerlink" title="以下代码是否能编译？"></a>以下代码是否能编译？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">java<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/* ... */</span> &#125;<br><br>Node&lt;Circle&gt; nc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;();<br>Node&lt;Shape&gt;  ns = nc;<br></code></pre></td></tr></table></figure><p>不能，因为Node<Circle> 不是 Node<Shape> 的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">/* ... */</span> &#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildNode</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;T&gt;&#123;<br>    <br>&#125;<br>ChildNode&lt;Circle&gt; nc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildNode</span>&lt;&gt;();<br>Node&lt;Circle&gt;  ns = nc;<br></code></pre></td></tr></table></figure><p>可以编译，ChildNode<Circle> 是 Node<Circle> 的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Number n : list)<br>        System.out.print(n + <span class="hljs-string">&quot; &quot;</span>);<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以编译，List 可以往外取元素，但是无法调用 add() 添加元素</p><h3 id="List-lt-extends-T-gt-和-List-lt-super-T-gt-之间有什么区别？"><a href="#List-lt-extends-T-gt-和-List-lt-super-T-gt-之间有什么区别？" class="headerlink" title="List&lt;? extends T&gt; 和 List&lt;? super T&gt; 之间有什么区别？"></a><code>List&lt;? extends T&gt;</code> 和 <code>List&lt;? super T&gt;</code> 之间有什么区别？</h3><p>这两个List的声明都是限定通配符的例子，<code>List&lt;? extends T&gt;</code>可以接受任何继承自T的类型的List, 而<code>List&lt;? super T&gt;</code> 可以接受任何T的父类构成的List. 例如<code>List&lt;? extends Number&gt;</code> 可以接受<code>List&lt;Integer&gt;</code> 和 <code>List&lt;Float&gt;</code>。</p><h3 id="如何编写一个泛型方法，让他能够接受泛型参数并返回泛型类型"><a href="#如何编写一个泛型方法，让他能够接受泛型参数并返回泛型类型" class="headerlink" title="如何编写一个泛型方法，让他能够接受泛型参数并返回泛型类型"></a>如何编写一个泛型方法，让他能够接受泛型参数并返回泛型类型</h3><p>需要用泛型类型来替代原始类型，比如使用T,E,K,V等被广泛认可的类型占位符。泛型方法的例子可能会像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key,V value)</span>&#123;<br>    <span class="hljs-keyword">return</span> cache.put(key,value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="你可以把List-lt-String-gt-传递给一个接受List-lt-Object-gt-参数的方法吗？"><a href="#你可以把List-lt-String-gt-传递给一个接受List-lt-Object-gt-参数的方法吗？" class="headerlink" title="你可以把List&lt;String&gt;传递给一个接受List&lt;Object&gt;参数的方法吗？"></a>你可以把<code>List&lt;String&gt;</code>传递给一个接受<code>List&lt;Object&gt;</code>参数的方法吗？</h3><p>不能。<code>List&lt;Object&gt;</code>可以存储任何类型的对象包括String,Integer等等，而<code>List&lt;String&gt;</code>只能用来存储String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Object&gt; objectList;<br>List&lt;String&gt; stringList;<br>objectList=stringList;<span class="hljs-comment">//compilation error incompatible types</span><br></code></pre></td></tr></table></figure><h3 id="Array中可以使用泛型吗？"><a href="#Array中可以使用泛型吗？" class="headerlink" title="Array中可以使用泛型吗？"></a>Array中可以使用泛型吗？</h3><p>Array并不支持泛型，所以Effective Java一书中建议使用List来替代Array,因为List可以提供编译期的类型安全保证，而Array不能。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>myBlog_bug_summarize</title>
    <link href="/2022/05/12/myBlog-bug-summarize/"/>
    <url>/2022/05/12/myBlog-bug-summarize/</url>
    
    <content type="html"><![CDATA[<h1 id="SNAPSHOT-0-0-1"><a href="#SNAPSHOT-0-0-1" class="headerlink" title="SNAPSHOT-0.0.1"></a>SNAPSHOT-0.0.1</h1><ol><li><p>后台管理页面博客分类不显示</p><div align="center"><img src="1.png" width=500 ></div></li><li><p>编辑博客页面博客标题会被重置为“title”,分类会被清空。</p></li></ol><div align="center"><img src="2.png" width=500 ></div><ol start="3"><li><p>新增博客后不会提示新增成功</p></li><li><p>footer不贴底边会很丑。</p></li></ol><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><h3 id="问题1-分析步骤："><a href="#问题1-分析步骤：" class="headerlink" title="问题1. 分析步骤："></a>问题1. 分析步骤：</h3><ol><li>前台代码逻辑无误的情况下，怀疑后台没有将type id和name传递给前端，在Controller层打断点<div align="center"><img src="4.png" width=500 ></div></li></ol><p>发现type id 字段为blogId,name为空</p><div align="center"><img src="5.png" width=500 ></div><ol start="2"><li><p>在service层找到查询所有博客调用的持久层方法</p><div align="center"><img src="6.png" width=500 ></div></li><li><p>在mapper中找到方法的sql语句</p><div align="center"><img src="7.png" width=500 ></div></li></ol><div align="center"><img src="8.png" width=500 ></div>发现type 字段的名字不同，进行统一，bug解决。<div align="center"><img src="9.png" width=500 ></div><h3 id="问题2-thymeleaf标签添加错误。修正后解决。"><a href="#问题2-thymeleaf标签添加错误。修正后解决。" class="headerlink" title="问题2. thymeleaf标签添加错误。修正后解决。"></a>问题2. thymeleaf标签添加错误。修正后解决。</h3><div align="center"><img src="3.png" width=500 ></div><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3."></a>问题3.</h3><h3 id="问题4-增加css样式将footer置底"><a href="#问题4-增加css样式将footer置底" class="headerlink" title="问题4. 增加css样式将footer置底"></a>问题4. 增加css样式将footer置底</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- content --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>&#125;<br><span class="hljs-selector-class">.content</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>bugs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jwt原理</title>
    <link href="/2022/05/09/jwt%E5%8E%9F%E7%90%86/"/>
    <url>/2022/05/09/jwt%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Token（缩写 JWT）是目前最流行的<strong>跨域认证解决方案</strong></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>** JWT将所有数据都保存在客户端，服务器认证以后，生成一个 JSON 对象，发回给用户，以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。服务器变成无状态了，从而比较容易实现扩展。</p><p>JWT是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准, 特别适用于分布式站点的单点登陆（SSO）场景。</p><p>JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><p><font color=#008000><strong>什么情况下使用JWT比较适合？</strong></font></p><p><strong>授权</strong>：这是最常见的使用场景，解决单点登录问题。因为JWT使用起来轻便，开销小，服务端不用记录用户状态信息（无状态），所以使用比较广泛；</p><p><strong>信息交换</strong>：JWT是在各个服务之间安全传输信息的好方法。因为JWT可以签名，例如，使用公钥&#x2F;私钥对儿 - 可以确定请求方是合法的。此外，由于使用标头和有效负载计算签名，还可以验证内容是否未被篡改。</p><h3 id="JWT的原理和流程"><a href="#JWT的原理和流程" class="headerlink" title="JWT的原理和流程"></a>JWT的原理和流程</h3><h4 id="跨域认证的问题"><a href="#跨域认证的问题" class="headerlink" title="跨域认证的问题"></a>跨域认证的问题</h4><p>互联网服务离不开用户认证。<strong>一般流程</strong>是下面这样：</p><ol><li>用户向服务器发送用户名和密码。</li><li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li><li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li><li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li><li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li></ol><p><strong>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</strong></p><p><font color="#008000">举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</font></p><p>一种解决方案是 <strong>session 数据持久化</strong>，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，<strong>所有数据都保存在客户端</strong>，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h4 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h4><p>JWT 的原理是，<strong>服务器认证以后，生成一个 JSON 对象，发回给用户</strong>，就像下面这样。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;张三&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;role&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;管理员&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018年7月1日0点0分&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</strong></p><p>服务器就不保存任何 session 数据了，也就是说，<font color="#FF000"><strong>服务器变成无状态了，从而比较容易实现扩展。</strong></font></p><h4 id="与session的区别"><a href="#与session的区别" class="headerlink" title="与session的区别"></a>与session的区别</h4><ol><li>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</li><li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险</li><li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li><li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li></ol><h4 id="JWT认证流程图"><a href="#JWT认证流程图" class="headerlink" title="JWT认证流程图"></a>JWT认证流程图</h4><img src="jtwProcess.png" style="zoom:60%;" /><ol><li>浏览器发起请求登录，携带用户名和密码；</li><li>服务端验证身份，根据算法，<strong>（加密过程）</strong>，将用户标识符打包生成 token,</li><li>服务器返回JWT信息给浏览器，JWT不包含敏感信息；</li><li>浏览器发起请求获取用户资料，把刚刚拿到的 token一起发送给服务器；</li><li>服务器发现数据中有 token，验明正身；</li><li>服务器返回该用户的用户资料；</li></ol><h4 id="JWT的6个优缺点"><a href="#JWT的6个优缺点" class="headerlink" title="JWT的6个优缺点"></a>JWT的6个优缺点</h4><ol><li>JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。</li><li><strong>当JWT未加密方法时，一些私密数据无法通过JWT传输。</strong></li><li><strong>JWT不仅可用于认证，还可用于信息交换。</strong> 善用JWT有助于减少服务器请求数据库的次数。</li><li>JWT的最大缺点是服务器不保存会话状态，所以<strong>在使用期间不可能取消令牌或更改令牌的权限。</strong>也就是说，<strong>一旦JWT签发，在有效期内将会一直有效。</strong></li><li>JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，<strong>JWT的有效期不宜设置太长。</strong>对于某些重要操作，用户在使用时应该每次都进行进行身份验证，且服务器无法主动使token失效</li><li>为了减少盗用和窃取，<strong>JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。</strong></li></ol><h3 id="JWT的数据结构"><a href="#JWT的数据结构" class="headerlink" title="JWT的数据结构"></a>JWT的数据结构</h3><h4 id="消息组成"><a href="#消息组成" class="headerlink" title="消息组成"></a>消息组成</h4><p>一个token分3部分，按顺序:</p><ul><li>头部(header)</li><li>载荷(payload)</li><li>签证(signature)</li></ul><p><strong>对象为一个很长的字符串，字符之间通过”.”分隔符分为三个子串。注意JWT对象为一个长字串，各字串之间也没有换行符，一般格式为：xxxxx.yyyyy.zzzzz。</strong></p><h4 id="头部-header"><a href="#头部-header" class="headerlink" title="头部(header)"></a>头部(header)</h4><p>JWT的头部承载两部分信息：</p><ul><li>声明类型，这里是jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Example for header Map</span><br>Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;alg&quot;</span>, <span class="hljs-string">&quot;HS256&quot;</span>);<br>map.put(<span class="hljs-string">&quot;typ&quot;</span>, <span class="hljs-string">&quot;JWT&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="载荷-payload"><a href="#载荷-payload" class="headerlink" title="载荷(payload)"></a>载荷(payload)</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。</p><p><strong>注意，JWT默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">JWT.create().withHeader(map) <span class="hljs-comment">// header</span><br>                .withClaim(<span class="hljs-string">&quot;iss&quot;</span>, <span class="hljs-string">&quot;Service&quot;</span>) <span class="hljs-comment">// payload</span><br>                .withClaim(<span class="hljs-string">&quot;aud&quot;</span>, <span class="hljs-string">&quot;APP&quot;</span>)<br>                .withIssuedAt(iatDate) <span class="hljs-comment">// sign time</span><br>                .withExpiresAt(expiresDate) <span class="hljs-comment">// expire time</span><br>                .withClaim(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;cy&quot;</span>) <span class="hljs-comment">// payload</span><br>                .withClaim(<span class="hljs-string">&quot;user_id&quot;</span>, <span class="hljs-string">&quot;11222&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="签名（signature"><a href="#签名（signature" class="headerlink" title="签名（signature)"></a>签名（signature)</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。首先，需要指定一个密钥(secret)。<strong>这个密钥只有服务器才知道，不能泄露给用户。</strong> 然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><p><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) </code></p><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就构成整个JWT对象token， 就可以返回给用户。</p><h4 id="JWT的用法"><a href="#JWT的用法" class="headerlink" title="JWT的用法"></a>JWT的用法</h4><p>客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中或sessionStorage中。此后，客户端将在与服务器交互中都会带JWT。如果将它存储在Cookie中，就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header Authorization字段中。</p><p><code>Authorization: Bearer &lt;token&gt;</code></p><p>当跨域时，也可以将JWT被放置于POST请求的数据主体中。</p><p><strong>优化方案：</strong></p><ul><li>在jwt token中，增加TokenId字段。</li><li>将TokenId字段存储在redis中，用来让服务端可以主动控制token拉黑等操作</li><li>牺牲了JWT去中心化的特点。</li><li>使用非对称加密。颁发token的认证服务器存储私钥：私钥生成签名。其他业务系统存储公钥：公钥验证签名。</li></ul><p>这里的redis只存储tokenId的黑名单，同时redis也可以分布式部署，读写分离。token认证服务器操作redis的master，其他redis同步master的数据。</p><h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h3><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>Cookie是浏览器保存在用户电脑上的一小段文本，用来保存用户在网站上的必要的信息。Web页面或服务器告诉浏览器按照一定的规范存储这些信息，并且在以后的所有请求中，这些信息就会自动加在http请求头中发送给服务器，服务器根据这些信息判断不同的用户。</p><div align="center"><img src="屏幕截图 2022-03-16 143317.png" width=500></div><p>Cookie相当于服务器给每个客户端都贴上了一个小纸条，上面记录了服务器给我们返回的一些信息，然后服务器看到这张小纸条就知道我们是谁了。</p><p>Cookie主要用途：在客户端设置一些信息用于后续验证用户的登录状态。</p><div align="center"><img src="屏幕截图 2022-03-16 143551.png" width=500></div><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>用户使用网站的服务，需要使用浏览器与Web服务器进行多次交互。HTTP协议本身是无状态的，需要基于HTTP协议支持会话状态（Session State）的机制。具体的实现方式是：在会话开始时，分配一个 唯一的会话标识（SessionID），并通过Cookie将这个标识告诉浏览器，以后每次请求的时候，浏览器都会带上这个会话标识SessionID来告诉Web服务器这个请求是属于哪个会话的。在Web服务器上，各个会话都有独立的存储，保存不同会话的信息。如果遇到禁用Cookie的情况，一般的做法就是把这个会话标识放到URL的参数中</p><div align="center"><img src="屏幕截图 2022-03-16%20143853.png" ></div><h4 id="Session一致性问题"><a href="#Session一致性问题" class="headerlink" title="Session一致性问题"></a>Session一致性问题</h4><p>当Web服务器从一台变为多台时，就会出现Session一致性问题。</p><div align="center"><img src="屏幕截图%202022-03-16%20144016.png" width=500 ></div><p>当一个带有会话标识的HTTP请求到了Web服务器后，需要在HTTP请求的处理过程中找到对应的会话数据（Session）。但是，现在存在的问题就是：如果我第一次访问网站时请求落到了左边的服务器，那么我的Session就创建在左边的服务器上了，如果我们不做处理，就不能保证接下来的请求每次都落在同一边的服务器上了。这就是Session一致性问题。</p><h4 id="Session一致性解决方案"><a href="#Session一致性解决方案" class="headerlink" title="Session一致性解决方案"></a>Session一致性解决方案</h4><ol><li>Session Stiky</li></ol><p>在单机的情况下，会话保存在单机上，请求也是由这个机器处理，因此不会有问题。当Web服务器变为多台以后，如果保证同一个会话的请求都在同一个Web服务器上处理，则对该会话来说，与之前单机的情况是一样的。</p><p>如果要做到这样，就需要<strong>负载均衡器能够根据每次请求的会话标识SessionID来进行请求转发</strong>，如下图所示。这种方式称之为Session Stiky方式。</p><div align="center"><img src="屏幕截图%202022-03-16%20144304.png" width=500 ></div>该方案本身非常简单，对于Web服务器来说，该方案和单机的情况是一样的，只是我们在负载均衡器上做了手脚。这个方案可以让同样Session的请求每次都发送到同一个Web服务器来处理，非常利于针对Session进行服务端本地的缓存。<p>反向代理层让同一个用户的请求保证落在一台server上呢？</p><ol><li>四层代理hash。反向代理层使用用户ip来做hash，以保证同一个ip的请求落在同一个server上（更推荐，保证传输层不引入业务层的逻辑）</li><li>七层代理hash。反向代理使用http协议中的某些业务属性来做hash，例如sid，city_id，user_id等，能够更加灵活的实施hash策略，以保证同一个浏览器用户的请求落在同一个server上</li></ol><p>缺点：</p><ul><li>如果有一台Web服务器宕机或者重启，则该机器上的会话数据就会丢失。如果会话中有登录状态数据，则用户需要重新登陆。</li><li>会话标识是应用层的信息，则负载均衡器要将同一个会话的请求都保存到同一个Web服务器上的话，就需要进行应用层（七层）的解析，这个开销比第四层的交换要大。</li><li>负载均衡器变为了一个有状态的节点，要将会话保存到具体Web服务器的映射，因此内存消耗会更大，容灾会更麻烦。</li></ul><ol start="2"><li>Session Replication<div align="center"><img src="屏幕截图%202022-03-16%20144554.png" width=500 ></div></li></ol><p>可以看到，在Session Replication方中，不再要求负载均衡器来保证同一个会话地多次请求必须到同一个Web服务器上了。而我们的Web服务器之间则增加了会话数据的同步。通过同步就保证了不同Web服务器之间的Session数据的一致。</p><p>问题：</p><ol><li><p>同步Session数据造成了网络带宽的开销。只要Session数据有变化，就需要将数据同步到其他所有机器上，机器数越多，同步带来的网络带宽开销就越大。</p></li><li><p>每台Web服务器都要保存所有的Session数据，如果整个集群的Session数很多的话，每台机器用于保存Session数据的内容占用会很严重。</p></li><li><p>Session数据集中存储</p><div align="center"><img src="屏幕截图%202022-03-16%20144812.png" width=500 ></div></li></ol><p>不同的地方是，Web服务器之间没有Session数据复制，并且Session数据也不是保存在本机了，而是放在了另一个集中存储的地方。这样，无论是哪台Web服务器，也无论修改的是哪个Session的数据，最终的修改都发生在这个集中存储的地方，而Web服务器使用Session数据时，也是从这个集中存储Session数据的地方来读取。对于Session数据存储的具体方式，可以使用数据库，也可以使用其他分布式存储系统。这个方案解决了Session Replication方案中内存的问题，而对于网络带宽，该方案也比Session Replication要好。</p><p>问题：</p><ul><li>读写Session数据引入了网络操作，这相对于本机的数据读取来说，问题就在于存在时延和不稳定性，不过由于通信基本发生在内网，问题不大。</li><li>如果集中存储Session的机器或者集群存在问题，这就会影响我们的应用。</li></ul><ol start="4"><li>Cookie Based<br>对于Cookie Based方案，它对同一个会话的不同请求也是不限制具体处理机器的。与Session Replication和Session数据集中管理的方案不同，这个方案是通过Cookie来传递Session数据的。具体如下图所示。<div align="center"><img src="屏幕截图%202022-03-16%20145008.png" width=500 ></div></li></ol><p>可以看出，我们的Session数据存放在Cookie中，然后在Web服务器上从Cookie中生成对应的Session数据。这就好比我每次都把自己的碗筷带在身上，这样我去哪家饭店吃饭就可以随意选择了。相对于前面的集中存储，这个方案不会依赖外部的一个存储系统，也就不存在从外部系统获取、写入Session数据的网络时延和不稳定性了。</p><p>不足：</p><ul><li>Cookie长度限制。由于Cookie是有长度限制的，这也会限制Session数据的长度。</li><li>安全性。Session数据本来都是服务器端数据，而这个方案是让这些服务端数据到了外部外部网络及客户端，因此存在安全性的问题。</li><li>带宽消耗。这里指的不是内部Web服务器之间的带宽的消耗，而是我们数据中心的整体外部带宽的消耗。</li><li>性能消耗。每次HTTP请求和响应都带有Session数据，对Web服务器来说，在同样的处理情况下，响应的结果输出越少，支持的并发请求就会越多。</li></ul><p>Cookie主要存储在客户端用于验证用户身份和登录信息。</p><p>web层、service层无状态是大规模分布式系统设计原则之一，session属于状态，不宜放在web层让专业的软件做专业的事情，web-server存session？还是让cache去做这样的事情吧。</p><p>综合而言，上述所有方案都是解决session问题的方案，对于大型网站来说，Session Sticky和Session集中管理是比较好的方案。</p><p><strong>redis管理机制</strong></p><div align="center"><img src="屏幕截图%202022-03-16%20150041.png" width=500 ></div><p>redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据，是Session集中管理的实现方案。</p><p>token:也称作令牌, 注意在客户端里存 userid（也就是token）、用户信息、密文，而服务端只有一段加密代码，用来判断当前加密后的密文是否和客户端传递过来的密文一致，如果不一致，就是客户端的用户数据被篡改了，如果一致，就代表客户端的用户数据正常且正确。<br>token 在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中。token 组成：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">·</span> <span class="hljs-attr">uid:</span> <span class="hljs-string">用户唯一身份标识</span><br><span class="hljs-string">·</span> <span class="hljs-attr">time:</span> <span class="hljs-string">当前时间的时间戳</span><br><span class="hljs-string">·</span> <span class="hljs-attr">sign:</span> <span class="hljs-string">签名,</span> <span class="hljs-string">使用</span> <span class="hljs-string">hash/encrypt</span> <span class="hljs-string">压缩成定长的十六进制字符串，以防止第三方恶意拼接</span><br><span class="hljs-string">·</span> <span class="hljs-string">固定参数(可选):</span> <span class="hljs-string">将一些常用的固定参数加入到</span> <span class="hljs-string">token</span> <span class="hljs-string">中是为了避免重复查库</span><br></code></pre></td></tr></table></figure><p>token 认证流程与 cookie 类似：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 用户登录，成功后服务器返回Token给客户端。<br><span class="hljs-bullet">2.</span> 客户端收到数据后保存在客户端<br><span class="hljs-bullet">3.</span> 客户端再次访问服务器，将 token 放入 headers 中<br><span class="hljs-bullet">4.</span> 服务器端校验。校验成功则返回请求数据，校验失败则返回错误码（401）<br></code></pre></td></tr></table></figure><p>为何 session 或 token 更适合存储在 redis</p><ul><li>session 或 token 访问频繁，对性能要求极高</li><li>session 或 token 不必担心丢失数据（丢失后，用户只需要重新登录即可）</li><li>与其他存储在 mysql 中的数据相比，session 或 token 的数据量较小</li></ul><p>为何其他网站数据不适合存储在 redis</p><ul><li>防止数据丢失</li><li>数据量大，内存成本高</li><li>操作频率不高</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/08/hello-world/"/>
    <url>/2022/05/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
